/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/js/alerts-route.js":
/*!********************************!*\
  !*** ./src/js/alerts-route.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _settings__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./settings */ \"./src/js/settings.js\");\n/* harmony import */ var _modules_helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modules/helpers */ \"./src/js/modules/helpers.js\");\n/* harmony import */ var _modules_single_alert__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modules/single-alert */ \"./src/js/modules/single-alert.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, \"_invoke\", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == _typeof(value) && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, \"_invoke\", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, \"throw\" === methodName && delegate.iterator[\"return\"] && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method) || \"return\" !== methodName && (context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a '\" + methodName + \"' method\")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, \"catch\": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n/**\n * alerts-route.js\n *\n * This file generates the alert accordion on specific route pages. The page\n * can be for a single route, or for multiple routes. Multiple routes will be\n * identified by a route header within the accordion. The data being pulled can\n * be either local or remote, which is controlled by the IS_REMOTE variable in\n * settings.js\n *\n * To change the local data, add the json file to dist/static/json and update the\n * variable in settings.js\n */\n\n\n\n\nwindow.addEventListener(\"DOMContentLoaded\", generateAlerts);\n\n/**\n * Init Function\n */\nfunction generateAlerts() {\n  return _generateAlerts.apply(this, arguments);\n}\n/**\n * Fetches API data\n * @returns data array for routes parsed from URL string\n */\nfunction _generateAlerts() {\n  _generateAlerts = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n    var alertContainer, data, alerts, accordion;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            alertContainer = document.getElementById(\"kcalert-accordion\");\n            if (!_settings__WEBPACK_IMPORTED_MODULE_0__.IS_REMOTE) {\n              _context.next = 7;\n              break;\n            }\n            _context.next = 4;\n            return getRemoteAlerts();\n          case 4:\n            data = _context.sent;\n            _context.next = 11;\n            break;\n          case 7:\n            _context.next = 9;\n            return fetch(_settings__WEBPACK_IMPORTED_MODULE_0__.LOCAL_ROUTE_DATA).then(function (res) {\n              return res.json();\n            });\n          case 9:\n            data = _context.sent;\n            // if local data is for a single route, set to an array\n            if (!_settings__WEBPACK_IMPORTED_MODULE_0__.ROUTE.includes(\"-\")) data = [data];\n          case 11:\n            // remove system alerts\n            data = removeSystemAlerts(data);\n\n            // if no alerts, don't render accordion\n            alerts = false;\n            data.forEach(function (route) {\n              if (route.alerts.length > 0) alerts = true;\n            });\n            if (alerts) {\n              _context.next = 16;\n              break;\n            }\n            return _context.abrupt(\"return\");\n          case 16:\n            // build accordion\n            accordion = new DocumentFragment();\n            accordion.append(buildAccordion(data));\n            alertContainer.append(accordion);\n          case 19:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _generateAlerts.apply(this, arguments);\n}\nfunction getRemoteAlerts() {\n  return _getRemoteAlerts.apply(this, arguments);\n}\n/**\n * Builds accordion container to hold service alerts\n *\n * @param {Array} data\n * @returns accordion panel within a div\n */\nfunction _getRemoteAlerts() {\n  _getRemoteAlerts = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n    var path, routeNames, routeIDs, data;\n    return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            // get route name from URL path\n            path = window.location.pathname;\n            routeNames = parseRoutes(path.split(\"/\").pop()); // get the route IDs\n            _context4.next = 4;\n            return Promise.all(routeNames.map( /*#__PURE__*/function () {\n              var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(routeName) {\n                return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n                  while (1) {\n                    switch (_context2.prev = _context2.next) {\n                      case 0:\n                        _context2.next = 2;\n                        return getRouteID(routeName);\n                      case 2:\n                        return _context2.abrupt(\"return\", _context2.sent);\n                      case 3:\n                      case \"end\":\n                        return _context2.stop();\n                    }\n                  }\n                }, _callee2);\n              }));\n              return function (_x3) {\n                return _ref.apply(this, arguments);\n              };\n            }()));\n          case 4:\n            routeIDs = _context4.sent;\n            _context4.next = 7;\n            return Promise.all(routeIDs.map( /*#__PURE__*/function () {\n              var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(routeID) {\n                return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n                  while (1) {\n                    switch (_context3.prev = _context3.next) {\n                      case 0:\n                        _context3.next = 2;\n                        return getAlertsByRoute(routeID);\n                      case 2:\n                        return _context3.abrupt(\"return\", _context3.sent);\n                      case 3:\n                      case \"end\":\n                        return _context3.stop();\n                    }\n                  }\n                }, _callee3);\n              }));\n              return function (_x4) {\n                return _ref2.apply(this, arguments);\n              };\n            }()));\n          case 7:\n            data = _context4.sent;\n            return _context4.abrupt(\"return\", data);\n          case 9:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4);\n  }));\n  return _getRemoteAlerts.apply(this, arguments);\n}\nfunction buildAccordion(data) {\n  // construct main panel\n  var toggleBlock = document.createElement(\"div\");\n  toggleBlock.setAttribute(\"class\", \"toggle advisory-block\");\n\n  // button\n  var button = document.createElement(\"input\");\n  button.id = \"toggle-advisory\";\n  button.setAttribute(\"type\", \"checkbox\");\n  button.setAttribute(\"name\", \"advisory\");\n  button.setAttribute(\"aria-hidden\", \"true\");\n\n  // button label\n  var label = document.createElement(\"label\");\n  label.setAttribute(\"for\", \"toggle-advisory\");\n  label.setAttribute(\"class\", \"toggle-head advisory-block-title with-description\");\n  label.textContent = \"Service Advisory\";\n\n  // status flag container\n  var statusFlags = document.createElement(\"span\");\n  statusFlags.setAttribute(\"class\", \"route-status\");\n\n  // get alerts by type\n  var flagData = (0,_modules_helpers__WEBPACK_IMPORTED_MODULE_1__.countAlertTypes)(data);\n\n  // add status icons based on alert type\n  if (flagData.ongoing > 0) {\n    var ongoingFlag = (0,_modules_helpers__WEBPACK_IMPORTED_MODULE_1__.createStatusFlag)(\"ongoing\", flagData.ongoing);\n    statusFlags.append(ongoingFlag);\n  }\n  if (flagData.upcoming > 0) {\n    var upcomingFlag = (0,_modules_helpers__WEBPACK_IMPORTED_MODULE_1__.createStatusFlag)(\"upcoming\", flagData.upcoming);\n    statusFlags.append(upcomingFlag);\n  }\n  label.append(statusFlags);\n  toggleBlock.append(button, label, createAlertsPanel(data));\n  return toggleBlock;\n}\n\n/**\n * Builds accordion section inner panel for a single route's alerts\n *\n * @param {Array} data\n * @returns alerts within a div element\n */\nfunction createAlertsPanel(data) {\n  // create panel to hold route alerts\n  var alerts = document.createElement(\"div\");\n  alerts.setAttribute(\"class\", \"toggle-inner\");\n  var isMultiple = data.length > 1;\n  data.forEach(function (data) {\n    alerts.append(generateRouteAlerts(data, isMultiple));\n  });\n  return alerts;\n}\n\n/**\n * Builds grouping of alerts\n *\n * @param {Array} data\n * @param {Boolean} isMultiple\n * @returns\n */\nfunction generateRouteAlerts(data, isMultiple) {\n  var routeData = new DocumentFragment();\n\n  // build header section if multiple routes exist on this page\n  if (isMultiple && data.alerts.length > 0) {\n    var routeHeader = document.createElement(\"h3\");\n    routeHeader.setAttribute(\"class\", \"route-header\");\n    routeHeader.textContent = data.route_name;\n    routeData.append(routeHeader);\n  }\n\n  // print alerts\n  data.alerts.forEach(function (alert) {\n    routeData.append((0,_modules_single_alert__WEBPACK_IMPORTED_MODULE_2__.generateSingleAlert)(alert));\n  });\n  return routeData;\n}\n\n/**\n * Determines routes that exist within the URL path\n *\n * @param {String} path\n * @returns array of route names\n */\nfunction parseRoutes(path) {\n  var routes = [];\n  if (path[0].charAt(0).match(/[a-z]/i)) {\n    // if rapid ride...\n    // strip .html if working locally\n    if (path.includes(\".html\")) path = path.replace(\".html\", \"\");\n    routes[0] = path.replaceAll(\"-\", \" \");\n  } else {\n    // it's a numbered route, it could be multiple routes\n    routes = path.match(/(\\d+)/g);\n    // remove leading zeros\n    routes = routes.map(function (route) {\n      return route.replaceAll(/^0+/g, \"\");\n    });\n  }\n  return routes;\n}\n\n/**\n * Gets IBI route ID for route\n *\n * @param {String} apiKey\n * @param {String} routeName\n * @returns route ID\n */\nfunction getRouteID(_x) {\n  return _getRouteID.apply(this, arguments);\n}\n/**\n * Fetches alert data for a specific route by ID\n *\n * @param {String} apiKey\n * @param {String} routeID\n * @returns array of alerts\n */\nfunction _getRouteID() {\n  _getRouteID = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(routeName) {\n    var routes, route;\n    return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n      while (1) {\n        switch (_context5.prev = _context5.next) {\n          case 0:\n            _context5.next = 2;\n            return fetch(_settings__WEBPACK_IMPORTED_MODULE_0__.REMOTE_ROUTES_API).then(function (res) {\n              return res.json();\n            });\n          case 2:\n            routes = _context5.sent;\n            // find the route ID we're looking for based on its name\n            route = routes.mode[1].route.find(function (route) {\n              return route.route_name.toLowerCase() === routeName;\n            });\n            return _context5.abrupt(\"return\", route.route_id);\n          case 5:\n          case \"end\":\n            return _context5.stop();\n        }\n      }\n    }, _callee5);\n  }));\n  return _getRouteID.apply(this, arguments);\n}\nfunction getAlertsByRoute(_x2) {\n  return _getAlertsByRoute.apply(this, arguments);\n}\nfunction _getAlertsByRoute() {\n  _getAlertsByRoute = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(routeID) {\n    var fetchURL, alerts;\n    return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n      while (1) {\n        switch (_context6.prev = _context6.next) {\n          case 0:\n            fetchURL = _settings__WEBPACK_IMPORTED_MODULE_0__.REMOTE_SINGLE_ALERT_API + routeID; // find alerts based on route ID\n            _context6.next = 3;\n            return fetch(fetchURL).then(function (res) {\n              return res.json();\n            });\n          case 3:\n            alerts = _context6.sent;\n            return _context6.abrupt(\"return\", alerts);\n          case 5:\n          case \"end\":\n            return _context6.stop();\n        }\n      }\n    }, _callee6);\n  }));\n  return _getAlertsByRoute.apply(this, arguments);\n}\nfunction removeSystemAlerts(data) {\n  var res = data;\n  res.forEach(function (route) {\n    var alerts = [];\n    route.alerts.forEach(function (alert) {\n      var services = alert.affected_services.services;\n      for (var i = 0; i < services.length; i++) {\n        if (services[i].hasOwnProperty(\"route_name\")) {\n          alerts.push(alert);\n          break;\n        }\n      }\n    });\n    route.alerts = alerts;\n  });\n  return res;\n}\n\n//# sourceURL=webpack://kcalerts-restapi/./src/js/alerts-route.js?");

/***/ }),

/***/ "./src/js/modules/events.js":
/*!**********************************!*\
  !*** ./src/js/modules/events.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"clearButtons\": () => (/* binding */ clearButtons),\n/* harmony export */   \"clearSearch\": () => (/* binding */ clearSearch),\n/* harmony export */   \"notifyNoResults\": () => (/* binding */ notifyNoResults),\n/* harmony export */   \"searchRoutes\": () => (/* binding */ searchRoutes),\n/* harmony export */   \"showAlerts\": () => (/* binding */ showAlerts),\n/* harmony export */   \"toggleDetails\": () => (/* binding */ toggleDetails)\n/* harmony export */ });\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n/* Event Handlers\n ******************************************************* */\n/**\n * Remove ongoing styling from filter buttons\n *\n */\nfunction clearButtons() {\n  var bttns = document.getElementsByClassName(\"tab-btn\");\n  var _iterator = _createForOfIteratorHelper(bttns),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var bttn = _step.value;\n      bttn.removeAttribute(\"class\", \"selected\");\n      bttn.setAttribute(\"class\", \"tab-btn\");\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n}\n\n/**\n * Change the type of alerts in the view\n *\n * @param {String} show alert type to show\n * @param {String} hide alert type to hide\n */\nfunction showAlerts() {\n  var show = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n  var hide = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n  var accordion = document.getElementById(\"kcalert-accordion\");\n\n  // change accordion view\n  if (show === \"\") {\n    accordion.removeAttribute(\"class\", \"ongoing upcoming\");\n  } else {\n    accordion.removeAttribute(\"class\", hide);\n  }\n  accordion.setAttribute(\"class\", \"accordion accordion-flush \".concat(show));\n\n  // update buttons\n  clearButtons();\n  var bttn;\n  if (show === \"\") {\n    bttn = document.getElementById(\"reset\");\n  } else {\n    bttn = document.getElementById(\"\".concat(show, \"-filter\"));\n  }\n  bttn.setAttribute(\"class\", \"tab-btn selected\");\n}\nfunction toggleDetails(e) {\n  // const desc = e.target.parentElement.nextSibling;\n  var desc = e.target.nextSibling;\n  if (desc.style.display === \"none\") {\n    desc.style.display = \"block\";\n  } else {\n    desc.style.display = \"none\";\n  }\n  if (e.target.textContent === \"View details\") {\n    e.target.textContent = \"Hide details\";\n  } else {\n    e.target.textContent = \"View details\";\n  }\n}\nfunction notifyNoResults(element) {\n  var resize_ob = new ResizeObserver(function (entries) {\n    // since we are observing only a single element, so we access the first element in entries array\n    var rect = entries[0].contentRect;\n    var errorMsg = document.getElementById(\"no-alerts-msg\");\n    if (rect.height === 0) {\n      errorMsg.setAttribute(\"style\", \"display: block;\");\n      element.setAttribute(\"style\", \"border-color: transparent;\");\n    } else {\n      errorMsg.setAttribute(\"style\", \"display: none;\");\n      element.setAttribute(\"style\", \"border-color: #eee;\");\n    }\n  });\n\n  // start observing for resize\n  resize_ob.observe(element);\n}\n\n/**\n * Hides routes that do not include search input\n *\n */\nfunction searchRoutes() {\n  var showClear = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n  if (showClear) {\n    var clearBttn = document.getElementById(\"clear-search\");\n    clearBttn.setAttribute(\"style\", \"visibility: visible;\");\n  }\n\n  // get the search value\n  var input = document.getElementById(\"route-search\").value.toLowerCase();\n\n  // filter routes\n  var routes = document.getElementsByClassName(\"advisory-block\");\n  var _iterator2 = _createForOfIteratorHelper(routes),\n    _step2;\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var route = _step2.value;\n      var routeName = route.getAttribute(\"data-route\").toLowerCase();\n      if (!routeName.includes(input)) {\n        route.setAttribute(\"style\", \"display:none;\");\n      } else {\n        route.setAttribute(\"style\", \"display:block;\");\n      }\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n}\nfunction clearSearch() {\n  var clearBttn = document.getElementById(\"clear-search\");\n  clearBttn.setAttribute(\"style\", \"visibility: hidden;\");\n  var searchInput = document.getElementById(\"route-search\");\n  searchInput.value = \"\";\n  searchRoutes(false);\n}\n\n\n//# sourceURL=webpack://kcalerts-restapi/./src/js/modules/events.js?");

/***/ }),

/***/ "./src/js/modules/helpers.js":
/*!***********************************!*\
  !*** ./src/js/modules/helpers.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"accessibleText\": () => (/* binding */ accessibleText),\n/* harmony export */   \"cleanup\": () => (/* binding */ cleanup),\n/* harmony export */   \"convertEpoch\": () => (/* binding */ convertEpoch),\n/* harmony export */   \"countAlertTypes\": () => (/* binding */ countAlertTypes),\n/* harmony export */   \"createStatusFlag\": () => (/* binding */ createStatusFlag),\n/* harmony export */   \"expandType\": () => (/* binding */ expandType),\n/* harmony export */   \"icon\": () => (/* binding */ icon),\n/* harmony export */   \"incrementStatusType\": () => (/* binding */ incrementStatusType),\n/* harmony export */   \"isDART\": () => (/* binding */ isDART),\n/* harmony export */   \"isST\": () => (/* binding */ isST),\n/* harmony export */   \"organizeRoutes\": () => (/* binding */ organizeRoutes),\n/* harmony export */   \"printDates\": () => (/* binding */ printDates),\n/* harmony export */   \"processAlertDates\": () => (/* binding */ processAlertDates),\n/* harmony export */   \"routeLabel\": () => (/* binding */ routeLabel),\n/* harmony export */   \"statusText\": () => (/* binding */ statusText),\n/* harmony export */   \"uniqueRoutes\": () => (/* binding */ uniqueRoutes)\n/* harmony export */ });\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n/* Helper Functions\n ******************************************************* */\n\n/**\n * Outputs array of effective dates to human readable string\n *\n * @param {Array} dates Effective dates for the alert\n * @returns String\n */\nfunction printDates(dates) {\n  var str = \"Effective Dates: \";\n  for (var i = 0; i < dates.length; i++) {\n    if (i === dates.length - 1) {\n      str += \"and \".concat(processAlertDates(dates[i].effect_start, dates[i].effect_end));\n    } else {\n      str += \"\".concat(processAlertDates(dates[i].effect_start, dates[i].effect_end), \", \");\n    }\n  }\n  return str;\n}\n\n/**\n * Removes routes without ongoing alerts\n *\n * @param {Array} routes an array of routes with route_id, route_name, and alerts properties\n * @returns array of routes with ongoing alerts\n */\nfunction cleanup(routes) {\n  return routes.filter(function (route) {\n    return route.alerts;\n  });\n}\n\n/**\n * Filter array of routes so that only unique routes are listed\n *\n * @param {obj} alert\n * @returns array of routes to append this alert to\n */\nfunction uniqueRoutes(routes, type) {\n  if (type === \"alert\") {\n    return _toConsumableArray(new Set(routes.map(function (route) {\n      return route.route_id;\n    })));\n  } else if (type === \"route\") {\n    return _toConsumableArray(new Set(routes.map(function (route) {\n      return route;\n    })));\n  } else {\n    return [];\n  }\n}\n\n/**\n * Generates text for alert effective dates\n *\n * @param {Int} start\n * @param {Int} end\n * @returns String describing effective dates\n */\nfunction processAlertDates(startDate, endDate) {\n  var today = Math.round(new Date().getTime() / 1000);\n  var start = convertEpoch(startDate);\n  var end = convertEpoch(endDate);\n  if (start === end) {\n    // if start and end dates are the same, return one value\n    return start;\n  } else if (endDate < today) {\n    // if end date is out of range, swap end value for until further notice\n    return \"\".concat(start, \" until further notice\");\n  } else {\n    // else return date range\n    return \"\".concat(start, \" to \").concat(end);\n  }\n}\n\n/**\n * Generates string to call material icon that corresponds to alert type\n *\n * @param {String} effectName\n * @returns String that represents Material Icon\n */\nfunction icon(effectName) {\n  var text;\n  switch (effectName) {\n    case \"Trip Cancelation\":\n    case \"Suspension\":\n      text = \"error\";\n      break;\n    case \"Trip Restoration\":\n      text = \"task_alt\";\n      break;\n    case \"Stop Closure\":\n      text = \"dangerous\";\n      break;\n    case \"Multi-route Reroute\":\n    case \"Single Route Reroute\":\n      text = \"alt_route\";\n      break;\n    case \"Delay of Service\":\n      text = \"timer\";\n      break;\n    case \"Emergency Snow Network\":\n    case \"Snow Routes\":\n    case \"Snow Route\":\n      text = \"ac_unit\";\n      break;\n    default:\n      text = \"warning\";\n  }\n  return text;\n}\n\n/**\n * Replaces text in description that is difficult to parse for screen readers\n *\n * @param {String} desc\n * @returns expanded version of description\n */\nfunction accessibleText(desc) {\n  // if null, return\n  if (desc === \"\") return \"\";\n\n  // expand directionals\n  var res = \"\";\n  res = desc.replaceAll(/NB/g, \"Northbound\");\n  res = res.replaceAll(/SB/g, \"Southbound\");\n  res = res.replaceAll(/EB/g, \"Eastbound\");\n  res = res.replaceAll(/WB/g, \"Westbound\");\n\n  // expand streets\n  res = res.replaceAll(/ Ave?\\b/gm, \" Avenue\");\n  res = res.replaceAll(/ St\\b/gm, \" Street\");\n  res = res.replaceAll(/ Pl\\b/gm, \" Place\");\n  res = res.replaceAll(/ Rd\\b/gm, \" Road\");\n  res = res.replaceAll(/ Pkwy\\b/gm, \" Parkway\");\n  res = res.replaceAll(/ Blvd\\b/gm, \" Boulevard\");\n  res = res.replaceAll(/ Lk\\b/gm, \" Lake\");\n  res = res.replaceAll(/ Samm\\b/gm, \" Sammamish\");\n  return res;\n}\n\n/**\n * Expands alert type text for improved accessibility\n *\n * @param {String} type\n * @returns expanded version of alert type\n */\nfunction expandType(type) {\n  var res = \"\";\n  res = type.replaceAll(/ESN\\b/gm, \" Emergency Snow Network\");\n  return res;\n}\n\n/**\n * Generates text for status flag and alert classes\n *\n * @param {String} status\n * @returns String to display in status flag and classnames\n */\nfunction statusText(status) {\n  if (status === \"New\" || status.includes(\"Ongoing\")) return \"ongoing\";\n  return \"upcoming\";\n}\n\n/**\n * Transforms epoch date to local date\n *\n * @param {Int} epochts\n * @returns human readable string for date\n */\nfunction convertEpoch(epochts) {\n  // return new Date(epochts * 1000).toDateString();\n  return new Date(epochts * 1000).toLocaleDateString();\n}\n\n/**\n * Adjusts the route title based on route number\n *\n * @param {String} route\n * @returns String describing route type\n */\nfunction routeLabel(route) {\n  if (route === \"Duvall-Monroe Shuttle\") return route;\n  if (route.charAt(0).match(/[a-z]/i)) return \"RapidRide \".concat(route);\n  if (isST(route)) return \"ST \".concat(route);\n  if (isDART(route)) return \"DART \".concat(route);\n  return \"Route \".concat(route);\n}\n\n/**\n * Determines if a given route is DART\n *\n * @param {String} route\n * @returns boolean\n */\nfunction isDART(route) {\n  var routeNum = parseInt(route);\n  if (routeNum === 204 || routeNum === 224 || routeNum === 630 || routeNum === 631 || routeNum >= 901 && routeNum <= 930) {\n    return true;\n  }\n  return false;\n}\n/**\n * Determines if a given route operates under Sound Transit Express\n *\n * @param {String} route\n * @returns boolean\n */\nfunction isST(route) {\n  var routeNum = parseInt(route);\n  if (routeNum >= 500 && routeNum < 600) {\n    return true;\n  }\n  return false;\n}\n\n/**\n * Removes shuttle route and places it at the end of the array\n *\n * @param {Array} routes\n * @returns Array of routes in correct order\n */\nfunction organizeRoutes(routes) {\n  var shuttleRte = \"\";\n  var routeArr = [];\n  routes.forEach(function (route) {\n    if (route.route_id === \"102698\") {\n      shuttleRte = route;\n    } else {\n      routeArr.push(route);\n    }\n  });\n  return [].concat(routeArr, [shuttleRte]);\n}\nfunction countAlertTypes(data) {\n  var ongoing = 0;\n  var upcoming = 0;\n  data.forEach(function (route) {\n    route.alerts.forEach(function (alert) {\n      if (alert.alert_lifecycle === \"Upcoming\") {\n        upcoming++;\n      } else {\n        ongoing++;\n      }\n    });\n  });\n  return {\n    ongoing: ongoing,\n    upcoming: upcoming\n  };\n}\n\n/**\n * Increments alert status\n *\n * @param {String} alertStatus\n * @param {Object} routeStatus\n * @returns Object that holds status of alerts for the route\n */\nfunction incrementStatusType(alertStatus) {\n  var routeStatus = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n    ongoing: 0,\n    upcoming: 0\n  };\n  var res = routeStatus;\n  if (alertStatus.includes(\"Ongoing\") || alertStatus === \"New\") {\n    res.ongoing = res.ongoing + 1;\n  } else {\n    res.upcoming = res.upcoming + 1;\n  }\n  return res;\n}\n\n/**\n * Creates status flag\n *\n * @param {String} type\n * @param {String} text\n * @returns\n */\nfunction createStatusFlag(type, text) {\n  var flag = document.createElement(\"span\");\n  flag.setAttribute(\"class\", type);\n  flag.textContent = text;\n  return flag;\n}\n\n\n//# sourceURL=webpack://kcalerts-restapi/./src/js/modules/helpers.js?");

/***/ }),

/***/ "./src/js/modules/single-alert.js":
/*!****************************************!*\
  !*** ./src/js/modules/single-alert.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"generateSingleAlert\": () => (/* binding */ generateSingleAlert)\n/* harmony export */ });\n/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helpers */ \"./src/js/modules/helpers.js\");\n/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./events */ \"./src/js/modules/events.js\");\n\n\nfunction generateSingleAlert(alert) {\n  // alert panel\n  var alertPanel = document.createElement(\"div\");\n  alertPanel.setAttribute(\"class\", \"advisory-content \".concat((0,_helpers__WEBPACK_IMPORTED_MODULE_0__.icon)(alert.effect_name)));\n\n  // alert type\n  var type = document.createElement(\"h4\");\n  type.setAttribute(\"class\", \"advisory-type\");\n  type.textContent = alert.effect_name;\n\n  // alert flag\n  var flag = document.createElement(\"span\");\n  flag.setAttribute(\"class\", \"advisory-status \".concat((0,_helpers__WEBPACK_IMPORTED_MODULE_0__.statusText)(alert.alert_lifecycle)));\n  flag.textContent = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.statusText)(alert.alert_lifecycle);\n  type.append(flag);\n\n  // alert title\n  var title = document.createElement(\"p\");\n  title.setAttribute(\"class\", \"advisory-title\");\n  title.textContent = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.accessibleText)(alert.header_text);\n\n  // conditionally add description\n  var alertDescription = \"\";\n  if (alert.description_text) {\n    alertDescription = document.createElement(\"p\");\n    alertDescription.textContent = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.accessibleText)(alert.description_text);\n    alertDescription.setAttribute(\"class\", \"alert-description\");\n    alertDescription.setAttribute(\"style\", \"display:none;\");\n  }\n\n  // more details button\n  var expandLink = \"\";\n  if (alert.description_text) {\n    expandLink = document.createElement(\"a\");\n    expandLink.setAttribute(\"class\", \"expand-link\");\n    expandLink.addEventListener(\"click\", _events__WEBPACK_IMPORTED_MODULE_1__.toggleDetails);\n    expandLink.textContent = \"View details\";\n  }\n\n  // cause\n  var alertCause = \"\";\n  if (alert.cause_name) {\n    alertCause = document.createElement(\"p\");\n    alertCause.textContent = \"Cause: \".concat(alert.cause_name);\n    alertCause.setAttribute(\"class\", \"cause\");\n  }\n\n  // alert dates\n  var dates = document.createElement(\"p\");\n  dates.setAttribute(\"class\", \"advisory-dates\");\n  // if more than one effective date range\n  if (alert.effect_periods.length > 1) {\n    dates.textContent = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.printDates)(alert.effect_periods);\n    // else if only one effective date range\n  } else if (alert.effect_periods.length === 1) {\n    dates.textContent = \"Effective Dates: \".concat((0,_helpers__WEBPACK_IMPORTED_MODULE_0__.processAlertDates)(alert.effect_periods[0].effect_start, alert.effect_periods[0].effect_end));\n  }\n  var footer = document.createElement(\"p\");\n  footer.setAttribute(\"class\", \"alert-footer\");\n  footer.textContent = \"Alert ID: \".concat(alert.alert_id, \", Last Updated: \").concat((0,_helpers__WEBPACK_IMPORTED_MODULE_0__.processAlertDates)(alert.last_modified_dt, alert.last_modified_dt));\n  alertPanel.append(type, title, expandLink, alertDescription, alertCause, dates, footer);\n  return alertPanel;\n}\n\n//# sourceURL=webpack://kcalerts-restapi/./src/js/modules/single-alert.js?");

/***/ }),

/***/ "./src/js/settings.js":
/*!****************************!*\
  !*** ./src/js/settings.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"API_KEY\": () => (/* binding */ API_KEY),\n/* harmony export */   \"BASE_URL\": () => (/* binding */ BASE_URL),\n/* harmony export */   \"IS_REMOTE\": () => (/* binding */ IS_REMOTE),\n/* harmony export */   \"LOCAL_ALERTS_DATA\": () => (/* binding */ LOCAL_ALERTS_DATA),\n/* harmony export */   \"LOCAL_ROUTES_DATA\": () => (/* binding */ LOCAL_ROUTES_DATA),\n/* harmony export */   \"LOCAL_ROUTE_DATA\": () => (/* binding */ LOCAL_ROUTE_DATA),\n/* harmony export */   \"REMOTE_ALERTS_API\": () => (/* binding */ REMOTE_ALERTS_API),\n/* harmony export */   \"REMOTE_ROUTES_API\": () => (/* binding */ REMOTE_ROUTES_API),\n/* harmony export */   \"REMOTE_SINGLE_ALERT_API\": () => (/* binding */ REMOTE_SINGLE_ALERT_API),\n/* harmony export */   \"ROUTE\": () => (/* binding */ ROUTE)\n/* harmony export */ });\n/**\n * General Settings for API and data fetching\n */\n\nvar IS_REMOTE = true;\nvar BASE_URL = \"https://kcm-api.ibi-transit.com/developer/api/v2\";\nvar API_KEY = \"3QxRRLWBsUAZbfT62GEB2Q\";\n\n/**\n * Local Files - these will be used if IS_REMOTE is set to true\n *\n */\n\nvar LOCAL_ALERTS_DATA = \"../static/json/alerts20221207.json\";\nvar LOCAL_ROUTES_DATA = \"../static/json/routes.json\";\n\n// Specific Route Alerts - use only one and comment out the rest\n// const ROUTE = '007';    // single\n// const ROUTE = '271';     // single\nvar ROUTE = \"007-271\"; // multiple\nvar LOCAL_ROUTE_DATA = \"../static/json/route/\".concat(ROUTE, \".json\");\n\n/**\n * API Endpoints - these will be used if IS_REMOTE is set to false\n *\n * Example API calls\n * TEST: https://kcm-api.ibi-test.com/developer/api/v2/alerts?api_key=gvMjFrABizrQwye9KBD3KB&format=json\n * PROD: https://kcm-api.ibi-transit.com/developer/api/v2/alerts?api_key=3QxRRLWBsUAZbfT62GEB2Q&format=json\n */\n\nvar REMOTE_ROUTES_API = \"\".concat(BASE_URL, \"/routes?api_key=\").concat(API_KEY, \"&format=json\");\nvar REMOTE_ALERTS_API = \"\".concat(BASE_URL, \"/alerts?api_key=\").concat(API_KEY, \"&format=json\");\nvar REMOTE_SINGLE_ALERT_API = \"\".concat(BASE_URL, \"/alertsbyroute?api_key=\").concat(API_KEY, \"&route=\");\n\n\n//# sourceURL=webpack://kcalerts-restapi/./src/js/settings.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/js/alerts-route.js");
/******/ 	
/******/ })()
;